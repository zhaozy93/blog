# Unix系统
## 进程与内核
**内存页**: memory page,  操作系统内存页为单位管理内存，内存页的大小对系统性能有影响。 大小影响可参照硬盘的Block Size大小影响
**进程**: 是一个抽象的概念，传统unix中进程指在一个地址空间中执行单个指令系列。 地址空间由该进程可能引用或访问的内存位置的集合组成
	1. 每个进程都有单独的寄存器和内存
	2. 操作系统提供虚拟机，让每个进程误以为自己是唯一进程的假象
	3. 进程的地址空间是虚拟的，内核把进程的地址空间中内容存到各种存储对象中，内存、磁盘、交换区等
**控制点**: 使用 *程序计数器* 的硬件寄存器来跟踪指令序列，新版Unix在单个进程中支持多个控制点(线程)，因此一个进程内可以支持多个指令序列
**寄存器**: 每一个进程都有一组寄存器，系统有很多活动进程，但只有一组硬件寄存器。内核将正在运行的进程的寄存器内容保存到硬件寄存器，其他进程的寄存器内容保存在每个进程的数据结构中
**时间片**: 内核提供一种并发的假象，允许一个进程用于CPU一段时间(配额、10ms)，然后切换到另一进程。 这种操作方式称为时间片。  因为进程之间会争抢资源，如CPU、内存、外围设备等，抢不到的必须Block。
**内核**: 内核是一个特殊的程序，直接运行在设备上。实现了进程模块和其他系统服务，系统启动时，引导(bootstrap)从硬盘上加载内核，然后内核将一直驻留在内存中
	1. 对用户进程提供API
	2. 处理用户进程的各类异常
	3. 处理外围设备的硬件中断，设备使用中断机制来通知内核的I/O的状态变化。中断视为全局事件，与任何进程都没有关联
	4. 执行系统级别的任务
### 执行上下文
**执行模式**: Unix提供至少两种执行模式，较高特权的内核态(Kernel mode),一种较低特权的用户态(user mode)，主要是为了保护用户进程无法意外或恶意的损坏其他进程或者整个内核
**虚拟内存**: virtual address space. 进程使用地址不会直接引用物理内存的位置，通过一组地址转换映射表address translation map，将虚拟内存地址转为物理内存位置。
**页表**: page table方式来实现虚拟内存的映射。 表中一个条目对应进程的地址空间中的一页(page 固定大小的内存分配和保护单元)
**内存管理单元**: memory management unit 有一组寄存器来标识当前正在运行的进程的转换映射表，当CPU发生上下文切换时，内核会将这组寄存器和指针加载到新进程的转换映射表中。 这样就确保了一个进程只能引用他自己的空间地址
**系统空间、内核空间**: 每个进程的虚拟地址空间有一个固定的部分映射为内核的代码和数据结构内容，因为只有一个内核实例，因此所有进程都映射到了单个内核地址空间。  内核维护全局数据结构和每进程(pre-process)对象，每进程对象包含了允许内核访问任何进程地址空间的信息。 但内核访问当前进程可以直接通过MMU寄存器，因为MMU寄存器拥有了当前进程的必要信息。 虽然每个进程共享系统空间，但系统空间时受保护的，防止用户态访问。
**每进程对象**:  有两个特殊的对象，一般实现为进程地址空间中的一部分，但又不允许用户态访问，是为内核态所准备的
	1. u区: user area是一个数据结构，包含进程中内核感兴趣的信息，如进程打开的文件表、进程没有运行时所保存的进程寄存器的内容等。
	2. 内核栈: kernel stack每个进程有它自己的私有内核栈来跟踪它在内核中执行时的函数调用序列。
**执行上下文**: 有进程上下文和系统上下文。 
	1. 内核在进程上下文扮演当前进程的代理者，访问和修改进程的地址空间、u区、内核栈等，此外还会阻塞该进程以等待某个IO等
	2. 某些系统级任务必须在系统上下文中执行，如响应设备中断和重新计算进程优先级。 在执行系统上下文时，内核不能访问当前进程的地址空间等，同时内核不能被阻塞，甚至有时候没有一个当前进程
### 进程
进程是一个实体，运行一个程序并为他提供一个可执行的环境
	1. 包含一个地址空间和一个控制点
	2. 进程是基本的调度实体，一个CPU一次只能运行一个进程
	3. 进程之间互相抢夺资源
	4. 进程可以向系统请求服务，但由内核代其执行
	5. 进程拥有生命周期，一般通过fork或vfork系统调用创建，直到exit
	6. 进程生命周期内可以运行一个或多个程序，通过exec系统调用来运行新的程序
	7. 每一个进程都有一个父进程，可能有一个或多个子进程
	8. init进程(/etc/init程序)是所有用户进程的祖先，当一个进程结束时，如果他还有子进程，那么子进程变为孤儿进程(orphan)，并由init接管
**进程状态**: 进程总是处于某一明确定义的状态。进程会在对各种事件的响应中，从一个状态转移到另一个状态
	- 新建进程:
		1. fork调用创建一个初始initial状态 也称为idle空闲状态
		2. fork完后，将其转为 ready to run 状态
		3. 内核选择执行该进程，发起上下文切换，调用内核例程swtch()，进程的硬件上下文加载到系统寄存器中，并将控制权转给进程
	- 执行进程:
		1. 用户态下的进程因系统调用或中断进入内核态，并在完成时返回用户态
		2. 执行系统调用时，进程等待资源或事件，通过slepp()将进程置于睡眠的进程队列中，称为asleep状态。 
		3. 资源可用或事件可用时，内核唤醒该进程，进程处于就绪状态，等待调度
		4. 进程被调度时，首先在内核态，完成上下文切换，再交给用户态
		5. 调用exit，或信号而终止。 释放资源(除退出状态和资源使用情况)，进程处于僵死zombie状态。 保持状态知道父进程调用wait后再销毁进程，并将状态返回给父进程
	![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/unix2-3.jpeg)
**进程上下文**:
	1. 用户地址空间: 程序代码、数据、用户栈、共享内存区等
	2. 控制信息: 内核使用两个重要的数据结构来维护进程的控制信息, u区和proc结构。 还有自己的内核栈和地址转换映射表
	3. 凭据: 包含与它相关的用户ID和用户组ID
	4. 环境变量: 一组具有key=value格式的字符串，由父进程继承而来
	5. 硬件上下文: 一组通用寄存器和一组特殊的系统寄存器内容
		发生上下文切换时，将寄存器信息保存在u区的一个特殊部分中，即进程控制块process control block，并将新进程的PCB加载到硬件上下文
		1. 程序计数器寄存器program count: 持有下一条执行指令的地址
		2. 堆栈指针寄存器stack pointer: 包含栈最顶部元素的地址
		3. 状态标志寄存器processor status word: 几个包含系统状态信息的状态位。如当前或先前的执行模式，当前或先前的中断优先级级别，还有溢出和进位标志
		4. 内存管理寄存器memory management registers: 映射于集成的地址转换表
		5. 浮点运算单元Floating point unit寄存器
	6. 
**凭证**: 进程有两对ID，实际ID和有效地ID。用户登录时，使用账号密码对应的UID和GID来设置这两对UID和GID，进程fork时，从父进程获取凭证
	1. 使用exec运行处于suid模式的程序，进程的有效uid会改为该文件所有者的有效uid，sgid模式同理。  如/etc/passwd文件
	2. setuid和setgid，root用户可以更改实际和有效的uid、gid。 普通程序只能讲有效uid、gid改为实际uid和gid
**proc**: 很多实现中内核有固定大小的proc结构数组，称为进程表。 proc存在于系统空间里，因此任何时间都是对内核可见的。包含即使进程没有运行但也可能要用到的数据。
	1. 标识: 进程的唯一标识 ID
	2. 与该进程u区映射的内核地址映射表位置
	3. 进程状态
	4. 前向指针和后向指针，将进程链接到调度队列或将阻塞进程链接到睡眠队列
	5. 阻塞进程的睡眠通道
	6. 调度优先级和相关信息
	7. 信号处理信息
	8. 内存管理信息
	9. 该结构链接到活动、空间或僵死进程链表的指针
	10. 层次信息，描述与该进程相关的其他进程关系，如父进程、子进程
	11. 其他杂项
**u区**:  是进程空间的一部分，意味着只有进程运行时它才会被映射，才是可见的。上下文切换的重要步骤就是重置该映射，一边内核可以访问到真实的物理位置。 u区只包含进程运行时所需要的数据
	1. 进程控制块: 存放进程来运行时已经保存的硬件上下文内容
	2. 指向该进程proc结构的指针
	3. 实际的和有效的UID、GID
	4. 信号处理函数和相关信息
	5. 传递当前系统调用的参数和从当前系统调用的返回值和错误代码
	6. 程序头部信息、如代码、数据、栈大小以及其他内存管理信息
	7. 打开的文件描述符表
	8. 指向当前路径、控制终端的vnode指针
	9. CPU使用情况统计等
	10. 每进程的内核栈也是u区的一部分

### 内核态执行
	1. 触发条件: 设备中断、异常、陷入或软件中断
	2. 内核接管控制权前查阅分发表dispatch table，包含处理这些事件的底层例程的地址，同时会将进程的一些状态(程序计数器、状态标志寄存器)内容保存到进程的内核栈
	3. 执行结束后，内核再还原该进程状态
**中断vs异常**:
	1. 中断不是由当前进程引发的，必须在系统上下文中处理，不能访问进程的地址空间或u区。
	2. 异常对进程是同步的，是进程自己相关事件引起的，异常处理例程在进程上下文执行，可以访问进程地址空间等。
**系统调用**:系统调用定义了由内核提供给用户进程的一组编程接口。
	1. 进程发起系统调用
	2. 系统执行特殊指令,将执行模式切换为内核态，控制权转移到定义在分发表里的系统调用处理程序
note:  
	1. 系统调用在内核态执行，但依旧是进程上下文，因此可以访问进程的地址空间
	2. 运行在内核态，使用的是调用进程的内核栈。 先将参数从用户栈复制到u区，并将进程硬件上下文内容保存在内核栈中
	3. 执行对应的内核函数
	4. 内核函数返回后，将返回值和错误状态保存在合适的寄存器，还原硬件上下文，返回用户态，控制权转移给库例程
**中断处理**: 
	1. 硬件中断是允许外围设备与CPU交互，通知CPU任务的完成、错误状态或其他需要紧急关注的事件。 这些中断与进程无关，因此是内核态、系统上下文执行。且不允许阻塞
	2. 内核也支持软件中断或陷入的概念，一般用于触发上下文切换或调度低优先级且与时钟相关的任务。
	3. 中断有优先级概念，允许高优先级插队处理
### 同步
任何时间，内核都可以有多个活动进程，但只有一个是实际运行的，但它们共享内核数据结构的同一份拷贝，有必要采取同步措施，防止内核被破坏
为了同步，最重要的一种技术就是UNIX内核不可抢占的，意味着一个进程运行在内核态时，不会被结束，即使时间配额已经用完了，必须等到该进程自愿放弃CPU。
**阻塞操作**: 某种导致进程阻塞的操作，将进程置于水淼状态直到操作完成
	1. 锁: 如同单个标志位，加锁时置位，解锁时清除。任何想使用该对象的进程必须先检查该对象是否被锁住，如果被锁住，进程必须阻塞，直到该对象被解锁。
		1. 检查能否加锁
		2. 进入特殊sleep队列或者加锁成功
		3. 解锁后幻想所有对应的等待进程
	![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/unix2-7.jpeg)
	2. 中断: 进程操纵内和数据结构期间可能会被设备中断，假设设备中断也要操纵同样的内核数据结构。  可以通过阻塞中断来解决。   阻塞中断的的方法是创建**临界区**,显示提升ipl，更高级别的中断，防止中断插队
### 进程调度
由于CPU是必须被共享的资源，内核中安排进程间可用CPU时间的部分叫调度器(scheduler)。 
**抢占式轮转调度策略**: 相同优先级的进程以轮转方式调用，每个进程运行时间固定，更高优先级进程变为可用时，执行更高优先级进程，无论当前进程是否使用完它的时间配额。影响优先级的两个因素nice、usage因子
	1. nice值可以通过nice系统调用来更改，进而影响优先级
	2. usage是进程最近CPU使用情况的度量。 程序不运行，内核会定期增加它的优先级，程序得到CPU时间，将减少优先级，以防止进程饿死(starvation)
	3. 内核中执行的进程如果等待资源或阻塞，可以放弃CPU，等再变为可运行时，会分配一个内核优先级。内核优先级比任何用户优先级都高！
### 信号
使用信号来通知进程异步事件的发生及异常处理，unix有需要多信息，但大都被保留用于特定目的，只有SIGUSR1和SIGUSR2可以给应用程序任意使用
**信号生成方式**: 
		1. 进程使用kill系统调用杀掉某个进程
		2. 终端响应某些按键
		3. 内核生成信号通知进程发生了硬件故障等
**处理方式**: 进程可以调用signal来指定其他处理动作来代替默认处理动作。
		1. 指定的函数处理信号
		2. 忽略该信号
		3. 恢复默认动作
		4. 临时阻塞一个信号
**处理过程**: 
		1. 内核生成信息，通过在proc结构中未决的信号屏蔽字上设置一个位来通知进程
		2. 进程被安排调度，进程主动检查该信号并响应。 
		3. 处理未决信号在返回正常用户级的处理之前进行
		4. 睡眠程序根据睡眠原因来决定是否提前中断睡眠或等待进程被唤醒
			1. 如果是用户输入这种未知性的则会主动终止睡眠
			2. 进程等待IO这种的很快就等待进程唤醒
### 新的进程
Unix每个进程一次可以运行单个程序，进程也可以在任何时候调用新的程序，生命期内运行多个程序
	1. fork和vfork来创建新进程
	2. exec调用新的程序
	3. exit用于终止一个进程
#### fork:
 父进程调用fork，子进程几乎是父进程的完整拷贝。 子进程的地址空间是父进程的拷贝，开始也运行着同样的程序。 子进程从fork返回后就开始了用户态下的执行。 父进程与子进程都是从fork返回，为了区分，返回0给子进程，返回子进程PID给父进程。 子进程从fork返回后立即调用exec执行新的程序，exec成功后子进程地址空间被新程序的地址空间取代，并且子进程第一条可执行的新程序指令设置到程序计数器中，在返回到用户态
fork要做许多工作，如初始化子进程的PID、proc结构，设置某些初始字段值，分配地址转换映射表、u区并将子进程设为可运行的，并放入调度器队列等
**优化**: 
	1. vfork不会复制父进程各种内容，而是子进程共享父进程的各种内容，甚至连地址映射表都共享，很危险 但速度很快
	2. 写时复制copy-on-write，将父进程的数据段、栈区的页临时设置为只读，并打上写时复制标志。子进程有自己的地址映射表但与父进程共享内存也，当父进程或子进程尝试修改某页时，会发生缺页异常。内核再去创建新的可写拷贝。 因此不需要完整复制。 如果子进程立即调用exit或exec，页就恢复到最初的保护方式，清除标记
#### exec
使用新程序的地址空间替代调用进程的地址空间。进程是vfork创建的则将地址空间还给父进程否则释放原地址空间。
	1. 解析路径、验证权限和可执行文件
	2. 判断SUID和SGID标识并处理
	3. exec的参数和环境变量复制到内核空间，当前用户空间将被销毁
	4. 为数据段和栈区分配交换空间
	5. 释放旧的地址空间和关联的交换空间。vfork创建的将返还给父进程
	6. 分配地址映射表,新的地址空间
	7. 参数和环境变量赋值回新的用户栈
	8. 恢复默认的信号处理方式
	9. 初始化硬件上下文。多数寄存器重置为0，程序计数器设置为改程序的入口点
#### exit
	1. 关闭所有信号，关闭所有打开的文件，释放本地文件和其他资源
	2. 写入会计日志accounting log
	3. 在proc结构中保存资源使用情况和exit状态
	4. 状态更改为SZOMB僵死，并将proc结构放入僵死进程列表
	5. init进程继承当前进程的所有子进程
	6. 释放地址空间、u区、地址转换表和交换空间等
	7. 通知父进程，如果父进程睡眠则唤醒他
	8. 调用swtch调度一个新的进程运行
**僵死状态**: 程序退出时，一直处于僵死状态，直到被父进程清除。 僵死状态唯一持有的就是proc结构，包含金城退出状态和资源使用情况信息，对父进程有用。 父进程调用wait来获取这也信息同时释放proc结构。 如果父进程先死，则由init进程代理

## 线程和轻量级进程
**进程是组织资源的最小单位，线程是CPU执行的最小单位**
进程两个局限性，所以有了很多标准，内核线程、用户线程、内核支持的用户线程、C-threads、pthreads和轻量级进程
	1. 应用程序希望并发的执行一些大型的独立任务，但又必须与其他进程共享同一公共地址空间和其他资源
	2. 传统的进程无法充分利用多处理器体系架构的优点，进程一个时刻只能利用一个处理器，一个应用程序必须启动多个进程分发到多个处理器，同时还要同步彼此的任务
**资源**: [操作系统中的进程与线程 - CareySon - 博客园](http://www.cnblogs.com/CareySon/archive/2012/05/04/ProcessAndThread.html) 
**并行与并发**:
	1. 并行受限于可用的处理器的数目
	2. 并发取决于应用程序如何编写的，以及多少个线程可以在恰当的可用资源下同时执行
	3. 系统并发: 内核提供的系统并发通过识别进程里的多个控制进程并独立的调度他们，这些线程会在可用的处理器上得到复用。
	4. 用户并发: 通过用户级别的线程库来通过用户并发，无法被内核识别，由应用程序自己调度和管理，不是真正的并发或并行，因为这些线程实际上没有并行的运行。
	5. 用户并发和系统并发结合使用更好，即减少了过多系统并发的昂贵资源开销，又为用户提供了一个更加自然的编程模型
**进程**: 进程是一个复合体，包含一组线程和一系列资源。
	1. 线程表示进程的一个控制点，并且执行一系列指令，同时有自己的私有对象，如程序计数器、栈、寄存器上下文等
	2. 资源包含地址空间、打开的文件、用户凭证、配额等内容，被所有线程共享
**内核线程**: 内核线程不需要与用户进程关联。由内核内部根据需要创建和销毁，负责执行特殊的功能。 内核线程共享了内核的代码和全局数据，有自己的内核栈，可以被独立的调度和使用标准的内核同步机制如sleep、wakeup()。内核进程在执行异步IO特别有用，内核创建一个新的线程来处理IO请求，但在其他内核看来是异步操作。
**轻量级进程Lightweight Process**: 由内核支持的用户线程，内核线程的更高抽象。每个LWP由一个单独的内核线程来支持，LWP被独立的调用，但共享进程的地址空间和其他资源。 在多处理器上，LWP可以被分发到不同的处理器上运行，真正享受了并行的好处。  但LWP如果有过多的同步操作(如锁)等会有大量的系统调用，则性能会较低。 
	1. 系统调用需要两次两个模式的切换，用户态—>内核—>用户，开销很大
	2. LWP不适用于那些需要大量线程的应用程序，因为LWP的开销很大
**用户线程**: 用户级别上阐述，不需要内和了解线程的任何东西。用户线程的实现变为可行是因为线程的用户级别的上下文不需要内核的交互就可以完成保存和恢复。每个用户线程有自己的用户栈、保存用户级别寄存器上下文和其他状态信息。 内核仍负责进程切换，因为内核具有修改内存管理寄存器内容的权限。
	- 优点: 性能优势，十分轻量，因为切换都是实现在用户级别上，无需系统调用
	- 劣势:
		- 线程库负责调度用户线程，内核负责调度底层的进程或LWP，彼此不知道对方在做什么。 如一个LWP上层的用户线程加了一个锁，随后该LWP被内核抢占了，那么之后的用户进程想访问这个锁都是出于忙等待状态
		- 大多数应用程序基于所有线程最终得到调度假设的，当一个用户线程对应一个LWP是假设是成立的，但当多个用户线程对应少量LWP时，假设可能不成立。假设一个用户线程运行一个阻塞式的系统调用时阻塞在内核中，进程可能不会允许此LWP，那么将会产生假设失败
**轻量级进程设计**: 保证在至少单线程的情况下，妥善保留UNIX语义。 意味着包含一个单独LWP的进程必须表现的与传统UNIX进程一样。
	1. fork语义: 在传统UNIX中，fork就是对父进程的完整拷贝。 对单线程，也比较清晰，但对多线程fork单个LWP还是全部LWP都有问题
		1. fork单个LWP高效。因为用户空间有一个数据结构来表示每个用户线程，fork调用fork的那个LWP线程则代表任何用户线程都无法找到对应的LWP映射。
		2. fork所有LWP。父进程的LWP可能阻塞在一个系统调用中，他的状态在子进程中变得无法定义。LWP可能有网络连接，子进程中关闭可能会导致不期的效果等
	2. 多个LWP操作同一个文件容易出问题，比如文件偏移量是保存在文件描述符中，对所有LWP共享的，因此必须保证线程安全的，可以通过原子锁进行
	3. 信号处理，必须决定哪个LWP来处理信号，同样用户线程也有这个问题，信号传递给LWP后，哪个用户线程处理信号也有问题。
		1. 启发式的决定信号所给的线程: 谁引发就发给谁
		2. 随机发给一个线程: 
		3. 发给所有线程: 如终止信号
	4. 可见性: 同一个进程的LWP有互相直销彼此的需求，提供一个系统吊用来允许某个LWP发信号给同进程的另一个LWP
**用户级别的线程库**:  线程库呈现怎样的编程接口给用户，如何使用操作系统提供的原语来实现。
	1. 编程接口: 
		1. 创建和终止线程
		2. 挂起和恢复线程
		3. 单个线程分配优先级
		4. 线程调度和上下文切换
		5. 通过信号量、互斥锁等手段完成同步活动
		6. 线程之间发送消息
	同时减少内核参与，
	2. 线程库实现
		1. 每个线程绑定到不同的LWP上，易于实现，但消耗太多资源
		2. 在一(组)LWP上复用用户线程，消耗少量资源，但无法以一种轻松的方式来保护某个特定线程上的资源
![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/unix3-7.jpeg)
### 调度器激活
基本原则: 内核和用户线程紧密结合。 内核负责处理器的分配，线程库负责调度。 线程库把影响处理器分配的事件通知给内核，内核完全控制处理器的分配。 线程库拿到处理器之后，可以决定哪个线程在哪个处理器上运行。内核拿走处理器后，线程库正确的分配线程在处理器上运行。

## 信号和会话管理
信号提供一种将系统事件通知给进程的机制，同时也是一种用户进程间通信与同步的原语机制。 
**信号生成与处理**: 信号提供了一个发生某个预定义事件时，执行特定过程的方法，事件由整数标识。有些事件是异步的通知如键盘按下control-c以中断信号给某个进程，有些是同步的如访问不存在的地址。 
	1. 某个需要通知进程的事件发生时，信号被生成
	2. 进程识别到信号到来，采取合适的动作来传送和处理该信号
	3. 信号生成和传送时间之内，信号对该进程来说是未决的pending
### 信号处理
**五种默认动作**:
	1. 中止abort:产生一个core转储文件core dump后终止该进程，将进程地址空间的内核和寄存器上下文写入进程当前目录下一个叫core的文件中
	2. 退出exit: 直接退出不产生core转储文件
	3. 忽略ignore: 忽略改信号
	4. 停止stop: 挂起该进程
	5. 继续continue: 如果该进程被挂起则恢复进程，否则忽略该信号
**用户自处理信号**: 用户可以为信号指定动作或调用信号处理函数。 甚至也可以选择阻塞该信号。但SIGKILL和SIGSTOP是两个特例，用户不能忽略、阻塞或为他们执行一个处理函数。 
**处理信号**: 任何信号必须由进程本身进行处理，也就是要求进程必须被调起运行。 但有些进程优先级比较低，可能信号处理就被进一步延迟了。 进程会在内核调用issig()函数来检查未决信号时才知道信号的存在，调用时机如下
	1. 从一个系统调用或中断返回用户态之前
	2. 恰好阻塞在一个可中断的事件之前
	3. 刚刚从一个可中断的事件醒来之后
如果issig返回true则内核调用psig来传送该信号。然后调用对应的处理方式
**信号的生成**:  异常、其他进程(发送kill等)、终端中断(control-c等)、作业控制、配额(进程超出CPU时间限制或文件大小限制)、通知(进程请求一些事件的通知，如IO就绪)、告警
**信号的嵌套**: 有可能存在多个信号同时对进程而言都是未决的，但进程一次只能处理一个信号。信号可能在执行某个信号处理函数时到达，这可能引起信号处理函数的嵌套。 因此在实现中，用户调用一个信号处理函数之前会请求内核有选择的阻塞一些信号。
**睡眠与信号**:  睡眠分可中断睡眠和不可中断睡眠。 如短期时间导致的睡眠如IO一类属于不可中断睡眠，因为他时间可预期。 例如等待用户输入这一类属于可中断睡眠，因为时间不可预期。  
	1. 为不可中断睡眠生成一个信号，该信号被标记为未决状态，知道该进程唤醒后才处理
	2. 为可中断睡眠生成一个信号，将会在阻塞之前检查信号，如果发现存在信号则县处理信号并终止系统调用。如果信号在进程已经被阻塞后生成，内核将其唤醒，进程醒来可能是因为等待事件已经发生，也可能是睡眠被信号中断，调用issig检查信号
### 可靠地信号
	1. 持久的信号处理函数: 信号处理函数在信号发生后仍然保持已设置的状态
	2. 屏蔽:一个信号可以被临时屏蔽或阻塞
	3. 睡眠进程: 进程的部分信号处理信息对内核可见，这样进程睡眠时，如果是忽略或阻塞的信号，则进程不必唤醒该进程
	4. 解锁和等待: sigpause，自动取消对一个信号的屏蔽，并阻塞进程直到进程收到一个信号。   
### 进程组和终端管理
Unix提供进程组的概念来控制终端的访问和支持登陆会话。
**进程组**: 每个进程属于一个进程组，由进程的进程组ID标识。每个组可以有一个组长，这个组长进程的PID与它的进程组ID值相同。正常情况下，进程是从其父进程中继承进程组ID的，进程组里的所有进程都是组长进程的后代
**控制终端**: 每个进程可以关联一个控制终端，通常是进程被创建时的登陆终端。 同一组内的所有进程共享相同的控制终端。
**dev/tty文件**:  /dev/tty文件与每个进程的控制终端进行关联。这个文件的设备驱动程序简单的将所有的请求路由到合适的终端上去。 
**控制组**: 每个终端与一个进程组进行关联。这个组称为终端的控制组，由该终端的tty结构中的t_pgrp字段来标识。
**作业控制**: 一种机制，可以挂起或恢复一个进程组，并控制它对终端的访问。
#### SVR3模型
**进程组**: 每个进程在fork的时候继承父进程的进程组ID，改变进程组唯一方式是setpgrp系统调用，将调用者的进程组ID改为它的PID，调用者同时成为新的进程组的组长。
**控制终端**: 终端由它的控制组所拥有。当一个进程变为新的组长时，会失去它的控制终端，此后该进程打开的第一个终端将变为该进程的控制终端，该终端的t_pgrp也被设置为该进程的p_pgrp。子进程从组长继承控制终端。 因此两个进程组不会有同一个控制终端。
**终端信号**: 像SIGQUIT和SIGINT这样在键盘上生成的信号会发送给控制终端组里的所有进程，但这些信号实际上只作用于前台进程。 shell创建一个运行在后台的进程时会设置该进程忽略这些信号，shell也会重定向进程的标准输入为/dev/nulll，这样他们就不能通过文件描述符从终端读取内容
**分离终端**: 没有进程打开这个终端或者组长退出时发生，终端的t_pgrp设为0
**组长的消亡**: 组长消亡时，他的控制终端就与进程组失去了联系，此外会发送一个SIGHUP信号给所有组内的进程，这些进城的p_pgrp设为0，变成孤儿，不属于任何一个进程组
### 会话体系
	1. 每个进程属于一个会话和一个进程组。 
	2. 每个控制终端与一个会话和一个前台进程组存在关联
	3. 会话组长负责管理登录会话和把自己与其他会话隔离开来
	4. 只有组长有权分配和释放控制终端
![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/unix4-5.jpeg)
	1. 进程通过调用setsid来创建一个新的会话，用他的PID来设置会话ID和组ID，进程变为会话组长和进程组组长。 只要进程的PID是其他进程组的组ID则无法调用setsid，也就是说进程组组长无法直接调用setsid开启新的会话。 进程组组长必须移动到灵一个进程组来放弃它的进程组领导权再调用setsid开启新的会话和新的进程组
	2. 进程离开会话的唯一方式就是调用setsid开启一个新的会话，新回话中唯一成员就是这个进程
	3. 进程组在一个登录会话中表示一个作业。 一个单独的登录会话可以有几个活动的进程组，但只有一个是前台进程组，拥有对终端的无限访问权
























