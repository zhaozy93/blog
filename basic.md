# 各类基础知识点

## 进程与线程(浅显解释)

计算机核心是CPU，现代计算机都是多核CPU， 一个内核只能运行一个任务(进程)。如果任务(进程)过多就要排队等候。同时也就造成了进程与进程之间不共享内存。

一个进程则包含许多线程，线程们之间协助完成任务，那么他们就必须共享内存，但是资源(内存)的共享也是有限制的， 有些内存只能同时被一个线程访问，那么其余的就要排队(互斥锁)。还有一种资源(内存)可以被多人同时访问，那么超过数量限制的线程就也要排队等待(信号量)。

因此对于操作系统是多进程形式，允许多个任务同时运行。

对于程序是多线程，允许把单个任务分割成多个部分去完成。

通常把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位

---- 分割线

- 单进程单线程：一个人在一个桌子上吃菜。
- 单进程多线程：多个人在同一个桌子上一起吃菜。
- 多进程单线程：多个人每个人在自己的桌子上吃菜。

多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。

对于 Windows 系统来说，【开桌子】的开销很大(创建进程的时间开销很大)，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。

对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。

--- 分割线

一个任务主流执行方式
- 单线程串行执行 一个环节卡住了整体都卡住了， io与计算任务没区分开
- 多线程并行执行 开销主要在于创建线程以及线程执行期间上下文切换还有就是数据共享问题， 演变而来就是锁、状态同步等问题

reference: http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html

## JS的单线程

浏览器是单进程还是多进程呢？ 浏览器的实现方式不同。主要表现在多标签页时。

多进程浏览器：
- IE 10
- chrome
- opera 15或以上

多线程浏览器：
- IE 6
- oprea 12或以上
- Firefox

采用多进程的优点：
- 安全：现代系统都有进程的安全机制，单个进程有自己独立的内存空间
- 稳定：不会因为一个线程的崩溃导致整个应用的崩溃
- 性能

采用多进程的缺点：
- 内存占用大
- 进程间通讯的成本大
- 进程启动的开销大

JS异步机制
- JS的单线程是指一个浏览器进程中只有一个JS的执行线程
- 而异步机制是浏览器的两个或以上常驻线程共同完成的，例如异步请求是由两个常驻线程：JS执行线程和事件触发线程共同完成的，JS的执行线程发起异步请求（这时浏览器会开一条新的HTTP请求线程来执行请求，这时JS的任务已完成，继续执行线程队列中剩下的其他任务），然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理。

## 并发、并行与串行

- 并发是两个队列交替使用一台咖啡机，
- 并行是两个队列同时使用两台咖啡机，
- 串行，一个队列使用一台咖啡机，那么哪怕前面那个人便秘了去厕所呆半天，后面的人也只能死等着他回来才能去接咖啡，这效率无疑是最低的。
区别
- 并发的关键是你有处理多个任务的能力，不一定要同时。
- 并行的关键是你有同时处理多个任务的能力。
- 并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。

## Node.js异步IO
其实异步IO的本质与 前面提到的  *JS的单线程* 标题下面*JS异步机制* 类似
![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/nodejs01.jpeg)

## 阻塞IO与非阻塞IO、异步IO与同步IO

1、 异步IO* 与 *阻塞IO* 听起来很类似， 目的上也确实达到了我们前面图片描述的那样 并行执行IO的目标。 但本质是不一样的
*系统内核只有 *阻塞IO与非阻塞IO* 两种
  - 阻塞IO的意思就是应用程序要等待系统完成所有的IO操作调用才算结束，程序才能继续执行。 读取文件为例就是磁盘寻道-->读取数据-->复制数据到内存-->调用结束， 结果就是CPU等待IO，浪费CPU性能
  - 非阻塞IO为调用之后系统立即返回，但是不包含真实数据，只有一个文件描述符。CPU可以继续做其他事情

2、 在非阻塞IO模式下程序如何得知IO完毕了呢？
  
为了获取完整数据，CPU需要不断的去重复调用IO来确认完成状态， 叫做轮询(非常类似于前端的轮询)
- read。它是最原始、性能最低的， 通过一直重复调用I/O的状态来完成数据的读取。在真正数据返回之前CPU一直浪费在调动、等待上面，效率极低
- select。 对read的一种改进， 通过文件描述符上的事件状态来判断， 不在进行无意义的重复read，但是有个限制 对多对1024个文件描述符同时检查
- poll。 对select的改进， 突破了1024的限制，但是文件多时效率还是极低
- epoll。 Linux下效率最高的IO方式。在轮询过程中如果没有真正数据就会休眠，直到IO结束后利用完成事件将它唤醒。 真正做到了时间通知、执行回调的方式，而不是遍历查询，节省CPU性能。

![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/nodejs02.jpeg)

轮询技术确实保证了非阻塞IO获取数据完整的要求，但对于应用程序而言仍然还是一种同步，因为要么处于遍历文件描述符、要么处于休眠状态。实际效果还是不够好

3、 现实的异步IO(主程序单线程模式下)

利用系统多开一个或多个线程执行阻塞或非阻塞IO， 在IO完成后通过线程之间的通信来告诉主线程 IO完毕

## Node.js 异步IO
1、Node.js自身执行模型---事件循环

 通俗讲Node.js最外层是一个While(true)的循环， 循环内部被称为Tick。
 ![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/nodejs03.jpeg)
 注意：这里的退出仅仅是Tick的退出 也就是进入下一次while循环

2、观察者  Tick中向谁询问是否还有事件

在Node中事件主要来源是网络请求和IO读取，每一类事件都有对应的观察者：I/O观察者、网络请求I/O观察者。 同时实现了观察者对事件的分类

事件循环是一个典型的*生产者与观察者*模型。 
- 异步IO、网络请求是生产者：为node产生源源不断地事件
- 事件被传递到对应分类的观察者那里
- 事件循环不断去询问观察者

在Windows下，这个事件循环基于IOCP创建， 在*nix下循环基于多线程创建。

3、请求对象

下图是node中执行fs.open()经历的过程
- js调用函数
- 调用核心模块的c++库
- 內建模块根据平台区分调用对应的不同平台的具体实现
- 在uv\_fs\_open()的调用过程中，我们创建了一个FSReqWrap请求对象， js调用时的参数都被传入给了uv\_fs\_open方法。至此对象封装完毕。
- window平台下，调用QueueUserWorkItem()将这个FSReqWrap对象推入线程池中。至此JS的调用结束
- JS线程继续执行后续的操作、计算等等
![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/nodejs04.jpeg)

4、回调函数

还是上面的例子，讲到过所有参数都传给了请求对象， 那么回调函数也赋给了FSReqWrap请求对象oncomplete_sym事件上面， 当文件打开后这个事件就被触发了。

IO线程在结束后会调用PostQueuedCompletionStatus(作用是通知IOCP状态有更改，并归还线程至线程池)通知IOCP 这里有一个事件结束了。

下一次Tick时候，会调用GetQueuedCompletionStatus()从观察者那里查询事件。 查到事件并且有回调函数那么就执行回调函数

![image](https://raw.githubusercontent.com/zhaozy93/blog/master/img-bed/nodejs05.jpeg)

注意 这里有一点说明。
- 组装好IO请求对象并推入线程池这是IO第一部分
- 回调通知是IO的第二部分(包含执行回调函数)。
- 也就是说我们的回调函数不是由我们自己的js调用，所以很多时候try catch是无效的



